export interface MatchCounts {
  /** @TJS-type integer */
  matched: number;
  /** @TJS-type integer */
  lobby: number;
  /** @TJS-type integer */
  answering_questions: number;
  /** @TJS-type integer */
  idle: number;
  /** @TJS-type integer */
  banned?: number;
}

export interface MatcherStatus {
  counts: MatchCounts;
}

/** A Response is a possible answer to a Question. */
export interface Response {
  /**
   * A unique identifier for this response.
   *
   * @TJS-type integer
   * */
  responseID: number;
  /** The text of the response */
  text: string;
}

/**
 * A Question is a survey question answered by the user so
 * they can be matched with someone who has opposing views.
 */
export interface Question {
  /**
   * A unique identifier for this question.
   *
   * @TJS-type integer
   **/
  questionID: number;
  /** The text of the question. */
  text: string;
  /** The list of possible responses. */
  responses: Response[];
}

export interface Prompt {
  question: Question;
  /** @TJS-type integer */
  yourResponse?: number;
  /** @TJS-type integer */
  theirResponse?: number;
}

/** Match is the person we're currently paired with. */
export interface Match {
  /** @TJS-type integer */
  matchID: number;

  member1: MatchMember
  member2: MatchMember

  questions: OverlappingQuestion[];
}

export interface MatchMember {
  /** @TJS-type integer */
  userID: number;
  sessionID: string;
}

export interface OverlappingQuestion {
  /** @TJS-type integer */
  questionID: number;
  /** @TJS-type integer */
  response1?: number;
  /** @TJS-type integer */
  response2?: number;
}

/**
 * Session is generated by Conn and shared with the 'matcher' service.
 * It lets the matcher know about an active WebSocket connection waiting for a match.
 */
export interface Session {
  sessionID: string;
  /** @TJS-type integer */
  userID: number;
  /** time when the websocket was created */
  createTime: Date;
  /** time when the user pressed 'join the match pool' */
  matchTime?: Date;
  /** time when the websocket last disconnected */
  endTime?: Date;
  /** true if the websocket is currently connected */
  connected: boolean;
}

export interface User {
  /** @TJS-type integer */
  userID: number;
  firebaseID: string;
  email: string;
  phone: string;
  state: string;
  /** @TJS-type integer */
  age: number;
}

//
// HTTP request types
//

/* ProfileCreateRequest is sent as JSON to the ProfileCreate handler. */
export interface ProfileCreateRequest {
  email: string;
  state: string;
  /** @TJS-type integer */
  age: number;
}

/** ResponseSaveRequest is sent as JSON to the ResposneSave handler. */
export interface ResponseSaveRequest {
  /** @TJS-type integer */
  questionID: number;
  /** @TJS-type integer */
  responseID?: number;
}

/** FeedbackCreateRequest is sent as JSON to the FeedbackCreate handler. */
export interface FeedbackCreateRequest {
	feedback: string;
	report: string;
}

export interface FeedbackNotification {
  user: User;
  /** @TJS-type integer */
  matchID: number;
  feedback: FeedbackCreateRequest;
}
	

export interface PushTokenSaveRequest {
  token: string;
}

//
// WS Event Payloads
//

export interface PartnerInfo {
  /** @TJS-type integer */
  matchID: number;
  sessionID: string;
  state: string;
  /** @TJS-type integer */
  age: number;
}

export interface PartnerPayload {
  partner?: PartnerInfo;
  shouldInitiate: boolean;
  prompts: Prompt[];
  iceServers: RTCIceServer[];
}

export interface RTCIceServer {
  credential?: string;
  urls: string[];
  username?: string;
}

/**
 * SessionPayload is returned in response to a LoginEvent.
 * It indicates that a new session has been successfully
 * created and provides the SessionID so we can reconnect.
 */
export interface SessionPayload {
  sessionID: string;
}

export interface InfoPayload {
  counts: MatchCounts;
}

export interface ReadyPayload {}

export interface SignalPayload {
  to: string;
  data: any;
}

export interface ErrorPayload {
  message: string;
}

export interface HeartbeatPayload {}

/**
 * LoginPayload authenticates the Conn with a user account and launches
 * a new Session that allows them to match. It must be sent before any
 * other message will be accepted by Conn.
 */
export interface LoginPayload {
  /**
   * Unique ID of the session we're (re)connecting to. If the
   * connection is lost logging in with the same session id
   * will resume your session and connect you with your previous
   * partner.
   *
   * If the session id sent is owned by another user or somehow
   * invalid an 'error' event will be returned.
   */
  sessionID: string;
  /** A Firebase auth token (jwt) identifying the user. */
  token: string;
}

export type EventKind =
  | "login"
  | "error"
  | "match"
  | "partner"
  | "signal"
  | "ready"
  | "info"
  | "session"
  | "heartbeat";

export type ErrCode =
  | "unauthorized"
  | "bad_auth"
  | "match_failed"
  | "signal_failed"
  | "missing_to"
  | "conflict"
  | "invalid_email"
  | "invalid_state"
  | "invalid_age"
  | "invalid_phone"
  | "not_exist"
  | "already_authed"
  | "matcher_offline";
